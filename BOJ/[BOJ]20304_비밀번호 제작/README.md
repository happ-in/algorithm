# [백준 20304: 비밀번호 제작🧩](https://www.acmicpc.net/problem/20304)  
## sudo ✍  
처음에 이 문제를 풀었을 때 문제 자체를 이해 못했다.  
소오오올직히 이거 문제의 문장력이 아니 뭐... 그냥 조금 구려요... 그렇다구요...🤔  

<br/>  

비밀번호의 최댓값이 10^6이고 로그인에 시도된 번호 개수는 최대 10^5번이다. 완탐하면 시간초과날게 뻔한데 알고리즘의 시작은 완탐이랬으니 나는 당당히 완탐으로 풀었다! 결과는 볼 것 이 당연하지 뭐...   
완전탐색 코드가 궁금하신 분은 [여기](https://colorscripter.com/s/f3qUJL3)를 클릭하세요!

<br/>

알고리즘 분류에 BFS를 사용하라는데 어떤 방식으로 사용해야할지 도저히 모르겠어서 구글링을 했다. [여기](https://imksh.com/47#%EB%AC%B8%EC%A0%9C_%EC%84%A4%EB%AA%85) 사이트의 내용이 제일 깔끔하고 이해가 쉬웠다. 다른 분들 코드는 union-find를 기반으로 코드가 너무 길어서 이해를 못하겠다 😂😂 다음에 천천히 다시 봐야지...  (라고 적었으나 다른 문제 풀이였다 ㅋㅋㅋㅋㅋ)

<br/>  

**내가 이해한 내용**  
1. 로그인에 시도한 암호들을 큐에 넣는다.
2. 시도한 암호와 안전 거리가 1, 2, ... 인 숫자들을 bfs로 갱신하며 찾는다.  
    * 1이 하나인 2진법 숫자들과 비트 연산을 한다.
3. 안전 거리의 최댓값을 갱신하며 답을 찾는다.  

<br/>

2번의 말을 내가 쓰면서도 저게 뭔 말인가 싶고 어떻게 써야할지 모르겠다😤  
그래서 예시로 설명해야지!

```
[입력예시]                  [출력예시]
10                          2
2
3 4
```  

1이 하나인 2진법은 1, 10, 100 ... 이렇게 된다. 1이 하나인 2진법과 어떤 수가 XOR 연산을 하게 되면 결과를 result라고 하자. **result와 어떤 수의 XOR의 연산한 결과의 이진수는 1이 무조건 한 개**다. 왜냐하면 XOR 연산은 서로 다른 결과에 대해서만 1로 표시하고 같은 경우는 0으로 표시하기 때문이다. **a^b = result이고 result^a = b, result^b = a** 이다. 이해가 안간다면 직접 아무 숫자나 대입해보면 된다!  

<br/>

#### 2번
아무튼 이 원리를 이용해서 입력 예시 중 3을 예시로 들어보겠다!  
3은 이진수으로 표현하면 11이다. 11과 1, 10, 100을 XOR 해보면 10, 1, 111이 나온다. 십진수로 나타내면 2, 1, 7이 된다. 이 때, arr[1] = arr[2] = arr[7] = 1이 된다.  이제 1, 2, 7에 대해서 1, 10, 100을 XOR한다. 이 값들은 3과 안전 거리가 2가 된다. 그럼 2인 값들에 또 비트연산을 하면 그 값들은 3과 안전 거리가 3이다. 이렇게 bfs 탐색을 진행한다!

<br/>

## algorithm 💻  
1. 로그인에 시도한 암호들을 큐에 넣고 안전 거리를 체크할 배열을 만든다.  
    로그인을 시도한 암호는 안전 거리 배열에서 0으로 초기화한다.
    ```java
    int[] arr = new int[N+1];
    for (int i = 0; i < M; i++) {  
        q.add(n);
        arr[n] = 0;
    }
    ```

2. 시도한 암호와 안전 거리가 1, 2, ... 인 숫자들을 bfs로 갱신하며 찾는다. [원리](#2번)  
3. 안전 거리의 최댓값을 갱신하며 답(ans)을 찾는다.  
    ```java
    while (!q.isEmpty()) {
        int now = q.poll();
        for (int i = 0; i<20 ; i++) {
            int next = now ^ (1<<i);

            ...

            arr[next] = arr[now] + 1;
            q.add(next);
            ans = Math.max(ans, arr[next]); 
        }
    }
    ```
4. 끝!
