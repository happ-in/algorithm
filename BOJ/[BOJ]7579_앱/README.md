# [백준 7579번: 앱 📱](https://www.acmicpc.net/problem/7579)

### sudo ✍  
이 문제 바보같이 생각했다^^ memory값이 10^7인데 cost 비용도 10^7제곱으로 생각해서 아무리 고민해도 메모리초과가 나는 문젠데...이러고 있었다. 네 제가 바로 바보 멍청입니다 🙈🙉🙊  


### 아이디어  
1. i번째 앱까지 j만큼의 cost를 사용하는 dp[i][j] 배열 생성
2. 이중 for문을 사용해서 i번째 앱에서 비활성화 비용 j만큼 사용했을 때 확보하는 최대 메모리 구하기
3. 갱신하며 답 찾기

<br/>

### algorithm 💻  
1. dp[i][j] 배열 생성  
    ```java
    int[][] dp = new int[N + 1][costSum + 1];
    ```

<br/>

2. i번째 앱에서 비활성화 비용 j만큼 사용했을 때 확보하는 최대 메모리  
    * 현재 사용한 비용 j가 i번째 앱 비활성화 비용보다 작다면 i번째 앱을 비활성화하지 못하므로 dp[i-1][j] 값을 가져온다.
    * 크다면 dp[i-1][j]값과 dp[i-1][j-cost[i]] 값에서 현재 앱을 비활성화하고 얻은 메모리를 더한 값의 합 중 확보한 메모리가 큰 값을 가져온다.
    ```java
    for (int i = 1; i <= N; i++) {
        for (int j = 0; j <= costSum; j++) {
            if (j < cost[i]) dp[i][j] = dp[i-1][j];
            else dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-cost[i]] + memory[i]);
        }
    }
    ```
    * 여기서 costSum은 100 * 100을 줘도 되지만 조금의 최적화라도 하기 위해 cost배열의 합을 사용했다.

<br/>

3. 답 갱신  
    * 필요한 메모리만큼 충분한 메모리를 확보하고 최저의 비활성 비용인 경우
    ```java
    if (dp[i][j] >= M && ans > j) ans = j;
    ```

<br/>

### 느낀점 🌵
dp 문제를 볼 때마다 몇 개의 배열을 사용해야할지 고민된다. 후... 일차원 이차원 삼차원 고민고민... 그냥 내가 dp를 못 푸는거지 뭐... 그치만 손이 안간다 바로 뫼비우스의 띠 야호!  
아몰라 :) 
