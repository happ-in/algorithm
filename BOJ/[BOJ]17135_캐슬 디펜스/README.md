# [백준 17135: 캐슬 디펜스🏰](https://www.acmicpc.net/problem/17135)


## sudo ✍
이 문제 너무 화난다. 3번정도 갈아엎은 거 같다 ^^^

맨 처음에 문제를 순서대로 적어봤다.

#### 문제
```
1. 궁수 배치 선택
2. 동시에 적을 공격  
    * 가장 가까운 거리
    * 가장 왼쪽에 존재
3. 적이 한 칸씩 아래로 이동
```

<br/>

이걸보고 음 생각보다 쉽겠다! 하고 어떤 자료구조를 사용할 것인지 작성했다.

#### 도전1
```
1. 재귀로 궁수의 배치를 선택하고 3명이 선택되면 성을 방어!
2. 적을 PriorityQueue에 넣자!  
    정렬조건 → X값 크고 y값 작은 순!
3. Queue 값을 빼면서 최소인 값을 찾기  
    최소 값이 아닌데 값이 빠진 친구들은 tmp 큐에 넣기
4. 최소값 친구들 공격하고 적을 갱신
    * 모든 적을 tmp에 넣기
    * tmp에서 PriorityQueue로 옮기면서 x값을 +1하고 N을 넘어가는 애들은 없애기
5. 반복
6. 보기 좋게 실패😤
```

이 알고리즘에서 2번의 정렬 조건으로 가장 왼쪽에 있는 애들은 문제가 되지 않겠군! 이라고 생각을 했는데 멍청이었다. 거리 먼저 고려했어야했는데 ^^^ 그래서 당차게 실패!🤣

<br/>

그 다음 생각한 건 다음 알고리즘이다. 이 알고리즘은 수정의 수정을 거듭해 성공했다.  

#### 도전2
```
1. List에 적을 넣기
2. 궁수 배치
3. 가장 가까운 적 찾기  
    *  거리가 같은 경우 y 비교
4. 동시에 공격
5. 궁수의 x값 갱신
6. 반복
7. 성공💜
```

적들이 내려오는 과정이 너무 복잡하고 코드가 요란한 거 같아서 궁수들이 올라가는 걸로 해줬다. 적을 해치워 나가는 궁수 느낌🏹

<br/>

처음에 위에 알고리즘으로 구현을 완료하고 모든 테스트 케이스를 통과해서 제출했더니 바로 실패했다. 왜지? 하고 여러 테스트 케이스를 검색했는데 아래 테스트 케이스를 통해 내 코드의 잘못된 부분을 찾을 수 있었다.  


```
[입력]                          [출력] 
5 5 2                           14
1 0 1 1 1
0 1 1 1 1
1 0 1 0 1
1 1 0 1 0
1 0 1 0 1
```

이 문제는 소소하게 따져줘야하는 조건이 많았다. 손으로 적을 지워나가면서도 15명이 나와서 왜? 뭐가 문제지? 라고 생각을 했다. 문제를 천천히 읽으며 단어 하나하나 의미를 따지며 읽다가 '설마?'하고 외쳤다. 동시에 적을 공격한다는게 같은 적을 선택할 수도 있다는 건가? 라는 생각이 들어 그것을 고려하며 손으로 다시 적을 지웠다. 그러니까 14가 나왔다...🤬 이거 찾느라고 한시간 걸린 것 같다. 

<br/>

## algorithm 💻
1. List에 적을 넣기
    ```java
    if (parse(st.nextToken()) == 1) {
        enemy.add(new int[]{i, j});
    }
    ```

2. 궁수 배치 - **재귀**로 간단하게 해결!
    ```java
    for (int i = idx; i < M; i++) {
        archer[cnt] = i;
        dfs(cnt+1, i+1, archer);
    }
    ```

3. 캐슬 디펜스 시작   
    * 궁수 3명되면 시작!
        ```java
        if (cnt == 3) {
            defense(archer);
        }
        ```
    * 가장 가까운 적 찾기
        ```java
        int dist = Math.abs(X - enemy.get(j)[0]) + Math.abs(archer[i] - enemy.get(j)[1]);
        if (dist > D) continue; 
        if (dist < minDist) {
            minDist = dist;
            minIdx = j;
        }
        ```
    * 거리가 같은 경우 y 비교 (왼쪽에 존재하는지만 고려)
        ```java
        if (dist == minDist) {
            if (enemy.get(j)[1] < enemy.get(minIdx)[1]) {
                minIdx = j;
            }
        }
        ```
    * 동시에 공격
        * 동시 공격을 처리하기 위해 배열에 먼저 저장  
         → 죽은 적은 체크해주기 때문에 궁수 한 명마다 미리 체크해두면 큰일난다.
        ```java
        die[i] = minIdx;
        ```
        * 동시 공격하면서 죽은 적 카운팅
        ```java
        for (int d : die) {
            if (d != -1 && !visited[d]) {
                count++;
                visited[d] = true;
            }
        }
        ```
    * 궁수가 올라간다.
    ```java
    X--;
    ```
4. 반복
5. 성공

<br/>

## 느낀 점 🌵
* 문제를 처음부터 꼼꼼하게 읽자  
* 정렬할 것도 아니어서 그냥 int[]에 좌표를 담아줬는데 객체 생성을 했다면 .x .y 이렇게 보기 쉽게 코딩할 수 있었을 것 같다. 다음부터 복잡한 코드에는 그냥 객체 생성을 해야겠다.
