# [백준 2156번 : 포도주 시식 🍇](https://www.acmicpc.net/problem/2156)

## 시작은 노가다였다 (안 읽어도 되는 부분) 😬
1. 맨 처음에는 무작정 나올 수 있는 경우를 다 적어봤다.  
  ![image](https://user-images.githubusercontent.com/36289638/105982211-562f2780-60da-11eb-933f-3a71806a4847.png)


2.  그리고 각 숫자에 최대 값들을 적고 어떠한 조합으로 이루어진 것인지 적어봤다.
![image](https://user-images.githubusercontent.com/36289638/105982278-6b0bbb00-60da-11eb-9b13-7a3f4b1aca24.png)

3. 뭔가 규칙성이 나오는 것 같아서 테스트케이스의 값마다 최대값 선택하는 걸 적어봤다.
![image](https://user-images.githubusercontent.com/36289638/105982384-8aa2e380-60da-11eb-8144-9ccb563f9790.png)

4. 최대를 선택하는 값의 조합을 살펴보니 아래와 같은 공식이 나왔다.
    ```java
    Math.max(dp[i-3] + num[i-1] + num[i], dp[i-2] + num[i])
    ```

<br/>

## 내가 생각한 알고리즘 🤔 
### 🍷 포도주 선택하는 경우를 살펴보자 
1. i번째 값을 선택하려면 i-1번째와 i-2번째의 선택여부를 고려해야 한다.  
    ||i-3번째|i-2번째|i-1번째|i번째|
    |-|-|-|-|-|
    |선택여부|O|?|?|O|

<br/>

2. i-2번째가 O면 i-1번째는 X  
    ||i-3번째|i-2번째|i-1번째|i번째|
    |-|-|-|-|-|
    |선택여부|O|O|X|O|

    ```java
    dp[i-2] + nums[i]
    ```

<br/>

3. i-2번째가 X면 i-1번째는 O
    ||i-3번째|i-2번째|i-1번째|i번째|
    |-|-|-|-|-|
    |선택여부|O|X|O|O|

    ```java
    dp[i-3] + nums[i-1] + nums[i]
    ```

    <br/>

    **왜 dp[i-1] + nums[i]가 아닌가?**  
    이 경우는 연속으로 3잔을 선택한 경우가 포함될 수도 있기 때문이다!

    dp[i-1]이 가질 수 있는 경우 (중 2개)
    ||i-3번째|i-2번째|i-1번째|i번째|
    |-|-|-|-|-|
    |선택여부|O|X|O|O|

    ||i-3번째|i-2번째|i-1번째|i번째|
    |-|-|-|-|-|
    |선택여부|X|O|O|O|

<br/>

## 알고리즘 풀이 😄
1. 포도주의 입력을 받는다.
2. i번째 선택 시 최선의 선택을 한다.  
    * 만약 과거의 선택 중 max 값이 있을 수도 있으니 전 단계의 값과 비교
    ```java
     for (int i = 3; i < N; i++) {
        dp[i] = Math.max(dp[i-3] + nums[i-1] + nums[i], dp[i-2] + nums[i]);
        dp[i] = Math.max(dp[i-1], dp[i]);
    }
    ```
