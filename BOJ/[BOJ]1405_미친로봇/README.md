# [백준 1405번: 미친 로봇🤖](https://www.acmicpc.net/problem/1405)   

## sudo ✍  
문제 지문에 **절대/상대 오차는 10-9 까지 허용한다.** 는 구문을 보고 아 이건 double형에 분모, 분자값을 따로 가지고 있다가 계산을 해야겠다! 라고 생각을 했다.  

### 1번째 시도 (메모리초과)🙅‍♀ [[코드보기]](https://colorscripter.com/s/p5p0Cyn)
1. 상하좌우로 움직이면서 움직인 결과를 String으로 넘겨준다.  
2. 움직인 결과를 list에 넣는다.
3. 각 결과의 확률을 계산한다.  
    1. 분자끼리 분모끼리 곱을 한다.
    2. 최소 공약수로 분모, 분자를 나눈다.
    3. 구해진 확률들의 합을 구한다.
4. 구해진 확률의 합을 반환한다.  

<br/>  

주어진 예제와 구글링해서 나온 테스트 케이스들은 다 맞아서 넣었더니 **메모리초과**가 발생했다. 그래서 생각한게 움직인 결과를 list로 넣지 않고 바로 계산해주면 되지 않을까? 라고 생각해서 그 부분만 고쳤더니 **시간초과**로 바뀌었다!  

<br/>

이것저것 고치는데 틀렸습니다와 시간초과의 콜라보레이션이 발생했다. 아 그냥 단순하게 **확률을 double형 하나 들고 재귀 돌릴까?** 라는 생각을 했고 간단하게 코드를 작성했더니 **맞았습니다!!** 가 떴다. (갬동받고 왜 저렇게 복잡하게 코드 작성했을까 등 여러 생각이 들었다.😂😂) 

<br/>

### 5번째 시도 (성공)🙆  
1. 상하좌우 움직이면서 움직일 때마다 확률을 구한다.
2. 단순하지 않거나 확률이 0인 경우 pass
    * 확률이 0인 경우를 제함으로 시간적으로 단축!
3. 단순한 경로로 N번 이동한 확률 다 더하기

<br/>

## algorithm 💻  
1. 상하좌우 움직이면서 확률을 구한다.
2. 단순하지 않거나 확률이 0인 경우 pass
    ```java
    for (int i = 0; i < 4; i++) {
        int nx = x + dx[i];
        int ny = y + dy[i];
        if (map[nx][ny] || EWSN[i] == 0) continue;    // 2번
        
        ...

        combination(nx, ny, cnt+1, cal * EWSN[i] / 100);    // 1번
    
        ...
    }
    ```

3. 단순한 경로로 N번 이동한 확률 다 더하기
    ```java
    if (cnt == N) {
        sum += cal;
        return;
    }
    ```
