# [백준 2805: 나무 자르기 🌲](https://www.acmicpc.net/problem/2805)  

## 내가 생각한 알고리즘 💭
1. **첫 시도 실패 😰**
    1. 주어진 나무 배열(tree)을 정렬하자!  
        ```java
        Arrays.sort(tree);
        ```
    2. 나무 배열의 값으로 이분 탐색을 하자!  
        ```java
        int left = 0; int right = N;
        while (left < right) {
            int mid = (left + right) / 2;
            
            ...

            for (int i = mid+1; i < N; i++) {
            sum += (tree[i] - tree[mid]);

            ...
        }
        ```

    3. 보기 좋게 실패~

이유는 절단기의 최대 높이기 때문에 위의 알고리즘 대로라면 나무의 값 중에서 선택된다. 아래의 예시를 보자.

> [예제 입력]  
> 5 8  
> 6 10 10 15 15  

> [예제 출력]  
> 11

실제 최대 절단기 높이는 11 지만 위의 알고리즘으로는 10이 나온다.

<br/>

2. **두 번째 시도 성공 😍**  
    1. 주어진 나무 배열의 최대값을 절단기의 최대값으로 사용한다.  
     (나무는 잘라가야하니 절단기가 최대 나무값보다 클리는 없다.)
    2. 절단기 값을 최소값, 최대값의 중간 값으로 설정한다.
    3. 잘린 나무의 크기(M)과 비교하며 절단기 값을 조절한다.

<br/>

## 소스풀이 💡
1. **주어진 나무 배열(tree)의 최대값을 절단기의 최대값(right)으로 사용한다.**
    ```java
    Arrays.sort(tree);
    int right = tree[N-1];
    ```

    tree의 max 값만 알면 되기 때문에 굳이 정렬까지 할 필요가 없다고 생각했다.  
    Array.sort() 내부는 최적하된 퀵 소트로 이루어져있다고 알고 있다.  
    정렬 메소드는 복잡도가 O(nlogn)보다 조금 작겠지만 max값만 찾는거면 O(n)이면 될 것이다.  
    그래서 stream API에서 제공하는 max()를 사용해봤다.  
    ```java
    int right = Arrays.stream(tree).max().getAsInt();
    ```
    결과적으로 메모리의 사용량과 소요된 시간이 약간이지만 줄어들었다.

<br/>

2. **절단기 값을 최소값, 최대값의 중간 값으로 설정한다.**
3. **잘린 나무의 크기(M)과 잘린 나무들을 비교하며 절단기 값을 조절한다.**
    ```java
        while (left <= right) {             // 이분 탐색 시작
            int mid = (left + right) / 2;   // 2. 절단기 값을 중간 값으로 설정

            long sum = 0;            
            for (int i = 0; i < N; i++) {
                if(tree[i] > mid) {                        
                    sum += (tree[i] - mid);               
                }
            }

            // 3. 잘린 나무의 크기(M)과 잘린 나무 비교(sum) → 절단기 값 조절
            if (sum >= M) {                               
                left = mid + 1;
            } else {                                      
                right = mid-1;
            }
        }
    ```

<br/>

## 느낀 점 🤦
1. 범위값을 잘 보자!  
    * 사실 실패한 알고리즘으로 생각했던 이유가 N의 범위를 M의 범위로 잘못봤다. 그래서 while문 내부에서 계속 20억 번씩 돌면 프로그램이 돌아버리겠군! 해서였다.
    * 처음에 sum을 int로 둬서 망했다. 나무 크기가가 20억씩이나 된다니...😂
2. 문제를 잘 읽자
    *  worst case에서 20억번 이분탐색을 while문 안에 돌리면 그래도 이게 1초안에 안될텐데... 반신반의하면서 풀었다. 그런데 시간초과가 안뜨고 틀렸습니다 떠서 읭?하고 문제 다시 읽었더니 절단기의 최대값을 나무 배열의 값으로 가져온다니 바보였다...
