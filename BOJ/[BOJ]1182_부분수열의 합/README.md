# [백준 1182번: 부분 수열의 합 ➕](https://www.acmicpc.net/problem/1182)  
## sudo ✍
문제를 보자마자 조합 문제구나! 라는 생각이 들었다. 그래서 재귀가 아닌 최근에 배운 비트마스크를 사용해보고 싶어 비트연산으로 문제를 풀었다.  

#### 내 풀이법📔
1. 1부터 (1<<N번)까지 반복문을 돌린다.
2. 각 숫자를 이진법의 문자열로 변경한다.
3. 문자열 자리에 1이 있는 경우, 그 자리에 맞는 배열의 값을 더한다.
4. 더한 값이 S와 일치하는 경우 count를 증가한다. 

<br/>

**1번을 하는 이유!**  
0부터 3까지의 수를 이진법으로 변경해본다.  
|10진수|2진수|
|-|-|
|0|00|
|1|01|
|2|10|
|3|11|

0를 선택하지 않음, 1을 선택함으로 본다면 0~3의 이진법의 수가 2개의 값에서 선택할 수 있는 모든 경우를 표현했다. 똑같이 적용하면 **N개의 값에서 선택할 수 있는 모든 경우는 2^N개**가 되므로 (i<<N)까지 반목문을 돌리면 된다.



<br/>

## algorithm 💻
1. 1부터 (1<<N번)까지 반복문을 돌린다.
    ```java
    for (long i = 1, size = 1L << N; i < size; i++) {
        ...
    }
    ```

2. 각 숫자를 이진법의 문자열로 변경한다.
    ```java
    String s = Long.toBinaryString(i);
    ```

3. 문자열 자리에 1이 있는 경우, 그 자리에 맞는 배열의 값을 더한다.  
    sum+=arr[j]로 할 경우 11과 1100은 같은 결과값을 낸다.  
    0011, 1100으로 비교하고자 arr[N-len+j]라는 결론을 도출했다.
    ```java
    for (int j = 0, len = s.length(); j < len; j++) {
        if (s.charAt(j) == '1') sum += arr[N - len + j];
    }
    ```

4. 더한 값이 S와 일치하는 경우 count를 증가한다. 
    ```java
    if(sum == S) count++;
    ```

5. 끝!


<br/>

## 배운점 🌵
비트연산이 마냥 빠르진 않았다. 76ms가 나온 코드가 있어서 봤는데 그냥 빛 밖에 안보였다. 그리고 비트연산에서 자리수 맞추는게 생각보다 번거로웠다. 또, 크기가 큰 경우에 비트연산을 쓰면 long형을 벗어날 수도 있어서 자리수를 잘 보고 사용해야겠다는 생각을 했다!  