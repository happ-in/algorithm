# [백준 20440번: 🎵니가 싫어 싫어 너무 싫어 싫어 오지 마 내게 찝쩍대지마🎵](https://www.acmicpc.net/problem/20440)

### sudo ✍  
이 문제 아이디어는 [회의실 배정](https://www.acmicpc.net/problem/1931) 문제에서 가져왔다. 입장, 퇴실 시간을 정렬해서 저 두 시간들로 쿰척쿰척 비교하면 되겠다고 생각했다.

<br>

#### 아이디어
1. 모기의 입장 시간이 빠른 순으로 정렬한다.  
2. 정렬된 모기를 한마리씩 큐에 넣는다. (이 때, 큐는 퇴장이 빠른 순으로 한다.)
3. 큐에서 들어가는 모기의 입장시간보다 퇴실시간이 빠른 모기는 큐에서 뺀다.
4. 큐 size와 기존에 가장 많이 들었던 모기의 수 비교
    * 큐 size > 기존 모기 수
        * in값 = 현재 들어오는 모기의 시작 시간
        * out값 = 현재 큐에 있는 제일 작은 모기의 퇴실 시간
    * 큐 size == 기존 모기 수 && out값 == 현재 모기 입실시간
        * out값 = 현재 큐에 있는 제일 작은 모기의 퇴실 시간으로 확장

<br>

아무튼 그래서 이 문제 java로 1등이다!

<br>

### algorithm 💻  
1. 모기의 입장 시간이 빠른 순으로 정렬한다.  
```java
Collections.sort(list, (o1, o2) -> o1[0] - o2[0]);
```

2. 정렬된 모기를 한마리씩 큐에 넣는다. (이 때, 큐는 퇴장이 빠른 순으로 한다.)
3. 큐에서 들어가는 모기의 입장시간보다 퇴실시간이 빠른 모기는 큐에서 뺀다.
```java
Queue<int[]> q = new PriorityQueue<>((o1, o2) -> o1[1] - o2[1]);
for (int i = 0; i < N; i++) {
    int[] now = list.get(i);
    while (!q.isEmpty() && q.peek()[1] <= now[0]) q.poll(); // 3번
    q.add(now);                                             // 2번
}
```

4. 큐 size와 기존에 가장 많이 들었던 모기의 수 비교
    * 큐 size > 기존 모기 수
        * in값 = 현재 들어오는 모기의 시작 시간
        * out값 = 현재 큐에 있는 제일 작은 모기의 퇴실 시간
    ```java
    if (q.size() > count) {
        in = now[0];
        out = q.peek()[1];
        count = q.size();
    }
    ```

    * 큐 size == 기존 모기 수 && out값 == 현재 모기 입실시간
        * out값 = 현재 큐에 있는 제일 작은 모기의 퇴실 시간으로 확장
    ```java
    else if (q.size() == count) { 
        if (out == now[0]) out = q.peek()[1];
    }
    ```
